<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://neilzhang.github.io/</id><title>Neil</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2022-08-06T12:28:09+08:00</updated> <author> <name>zhanghuanbin</name> <uri>https://neilzhang.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://neilzhang.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://neilzhang.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 zhanghuanbin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>字符串大数相加</title><link href="https://neilzhang.github.io/posts/string-big-number-add/" rel="alternate" type="text/html" title="字符串大数相加" /><published>2022-08-06T12:17:00+08:00</published> <updated>2022-08-06T12:17:00+08:00</updated> <id>https://neilzhang.github.io/posts/string-big-number-add/</id> <content src="https://neilzhang.github.io/posts/string-big-number-add/" /> <author> <name>neil</name> </author> <category term="技术" /> <category term="算法" /> <summary> 题目 实现两个超大字符串整数加法，字符串整数会超过 long 存储上限，不允许使用相关系统库函数直接完成。注意：整数包含正负数。 思路 两个数都有可能是正负数，所以 a+b 有4种情况， a，b 都是正数, 则 a+b = |a|+|b| a，b 都是负数, 则 a+b = (-|a|)+(-|b|) = -(|a|+|b|) a 是正数，b 是负数，则 a+b = |a|+(-|b|) = |a|-|b| a 是负数，b 是正数，则 a+b = (-|a|)+|b| = -(|a|-|b|) 综上，只要实现 |a|+|b| 和 |a|-|b| 即可实现所有情况。 |a|+|b| 实现很简单，只要模拟加法过程即可。|a|-|b| 实现需要注意下结果的正负，绝对值大的减去绝对值小的，结果为正数；绝对值小的减去绝对值大的，结果为负数。 代码 p... </summary> </entry> <entry><title>Golang 避坑指南之 time.After</title><link href="https://neilzhang.github.io/posts/golang-bad-case-of-time-after/" rel="alternate" type="text/html" title="Golang 避坑指南之 time.After" /><published>2022-08-06T11:53:00+08:00</published> <updated>2022-08-06T11:53:00+08:00</updated> <id>https://neilzhang.github.io/posts/golang-bad-case-of-time-after/</id> <content src="https://neilzhang.github.io/posts/golang-bad-case-of-time-after/" /> <author> <name>neil</name> </author> <category term="技术" /> <category term="Golang" /> <summary> 如何简单实现请求调用的超时机制呢？有了 time.After 当然就很简单啦，代码如下： func AsyncCallWithTimeout1() { ctx, cancel := context.WithCancel(context.Background()) go func(ctx context.Context) { defer cancel() // 模拟请求调用 time.Sleep(200 * time.Millisecond) }(ctx) select { case &amp;lt;-ctx.Done(): fmt.Println("call successfully!!!") return case &amp;lt;-time.After(time.Duration(3 * time.Second)): fmt.Println("timeou... </summary> </entry> <entry><title>如何设计一个高并发系统</title><link href="https://neilzhang.github.io/posts/how-to-design-high-concurrency-web/" rel="alternate" type="text/html" title="如何设计一个高并发系统" /><published>2022-08-06T11:34:00+08:00</published> <updated>2022-08-06T11:36:10+08:00</updated> <id>https://neilzhang.github.io/posts/how-to-design-high-concurrency-web/</id> <content src="https://neilzhang.github.io/posts/how-to-design-high-concurrency-web/" /> <author> <name>neil</name> </author> <category term="技术" /> <category term="架构" /> <summary> 什么是高并发 高并发（High Concurrency）是指通过设计保证系统能够同时并行处理很多请求。 常用指标有： QPS，每秒响应请求数 TPS，每秒响应事务数 RT，响应时间，系统对请求做出响应的时间 Concurrency，并发数，系统同时能处理的请求数量 吞吐量：单位时间内处理的请求数量 提高并发的思路 降低 RT 提高 Concurrency 如何降低 RT 升级服务器和数据库硬件配置，最简单粗暴且有效的手段，但是硬件能带来的提升是有上限的 服务端引入缓存，缓存分为本地缓存和分布式缓存，可显著降低查询接口的响应时间 购买 CDN 服务，将图片、html、css、js等静态资源上传到 CDN，可显著降低用户打开页面的响应时间 业务优化，比如流程拆分，将实时性要求低的流程写入消息队列进行异步处理，将互相独立的流... </summary> </entry> <entry><title>Golang Slice 总结</title><link href="https://neilzhang.github.io/posts/golang-slice/" rel="alternate" type="text/html" title="Golang Slice 总结" /><published>2022-08-04T15:19:00+08:00</published> <updated>2022-08-06T11:36:10+08:00</updated> <id>https://neilzhang.github.io/posts/golang-slice/</id> <content src="https://neilzhang.github.io/posts/golang-slice/" /> <author> <name>neil</name> </author> <category term="技术" /> <category term="Golang" /> <summary> 什么是 Slice 切片是对数组的抽象，提供动态数组的能力。切片的长度是不固定的，随着元素的增加而动态变化。 数组与 Slice 的区别 数组 值类型 长度固定 编译期间检查下标访问越界行为 可以作为 map 的 key Slice 引用类型 长度可变 运行期间检查下标访问越界行为 不可以作为 map 的 key 适用场景 长度不固定 参数传递 用法示例 var nums []int // 声明切片 var arr = [3]int{4, 5, 6} // 初始化数组 nums = append(nums, 1, 2, 3) // 切片追加元素 l := len(nums) // 获取元素个数 c := cap(nums) ... </summary> </entry> <entry><title>图解 Golang Channel 原理</title><link href="https://neilzhang.github.io/posts/golang-channel/" rel="alternate" type="text/html" title="图解 Golang Channel 原理" /><published>2022-08-03T21:42:00+08:00</published> <updated>2022-08-06T11:36:10+08:00</updated> <id>https://neilzhang.github.io/posts/golang-channel/</id> <content src="https://neilzhang.github.io/posts/golang-channel/" /> <author> <name>neil</name> </author> <category term="技术" /> <category term="Golang" /> <summary> 基础概念 Channel 是 Golang 的核心类型，常用于多个 Goroutine 之间的通信。可以把 Channel 理解成是一个单向的管道，具有 FIFO 特性。 Channel 是有容量限制的 当容量是 0 时，称为无缓冲 Channel。发送和接收只有一方就绪时，就绪方会被阻塞直到另一方也就绪。 当容量大于 0 时，称为有缓冲 Channel。当传输中的元素个数超过容量时，发送方将会被阻塞直到有可用的缓冲空间出现；当传输中的元素个数为 0 时，消费方将会被阻塞直到缓冲空间出现新的数据。 数据结构 type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue ... </summary> </entry> </feed>
